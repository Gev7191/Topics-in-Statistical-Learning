fit_LM_26_50.K = glm(sal_26_50 ~ poly(sal_51plus, i), data = salary)
cv.err.K[,i] = cv.glm(salary, fit_LM_26_50.K, K = 10)$delta[1]
}
# plotting results
plot(cv.err.K[1,], type = 'l', col = 'red', xlab = "Polynomials' order",
ylab = "10-folds CV", main = "CV and adjusted CV for different polynomials")
lines(cv.err.K[2,], col = 'green')
points(which.min(cv.err.K), cv.err.K[1, which.min(cv.err.K)], col = "red", cex=2, pch=20)
legend('topright', legend = c('CV', 'Adj. CV'), col = c('red', 'green'), pch = 10)
require(glmnet)
set.seed(1)
# crate an X matrix excluding intercept
# x = cbind(salary$sal_midManager, salary$sal_employee, salary$sal_worker, salary$sal_18_25, salary$sal_51plus)
# y = salary$sal_executive
# probably for ridge
names(salary)
y = salary$sal_26_50
x = as.matrix(cbind(salary[, c(4:8, 13, 18, 20)]))
names(x)
# grid for lambda values
grid = 10^seq(1, -5, length = 100)
lasso.mod = glmnet(x, y, alpha = 1, lambda = grid)
dim(coef(lasso.mod))
# the norms are increasing in value because of the shrinkage
lasso.mod$lambda[1]                  # lambda value
sqrt(sum(coef(lasso.mod)[-1,1]^2))   # L2 norm of its coeff
lasso.mod$lambda[51]
sqrt(sum(coef(lasso.mod)[-1,51]^2))
lasso.mod$lambda[90]
sqrt(sum(coef(lasso.mod)[-1,90]^2))
# predict values for a new lambda, e.g. OLS
OLS = predict(lasso.mod, s = 0, type = "coefficients")[1:nrow(coef(lasso.mod)),]
# split the date leaving the 10% for CV
train = sample(1:nrow(salary), floor(nrow(salary)*0.9))
test = -train
y.test = y[test]
lasso.mod = glmnet(x[train,], y[train], alpha = 1, lambda = grid, thresh = 1e-12)
err.i = rep("NA", length(grid))
for (i in 1:length(grid)){
lasso.pred = predict(lasso.mod, s = grid[i], newx = x[test,])
err.i[i] = mean((lasso.pred - y.test)^2)
}
plot(log(grid), err.i, xlab = 'log Lambda', ylab = 'test set MSE',
main = 'Test MSE among different Lambdas', ylim = c(0, 10))
bestlam = grid[which.min(err.i)]
points(log(grid)[bestlam], err.i[bestlam], col ="red", cex=2, pch=20)
# high values of lambda are like fitting just the intercept
# using 10 folds CV
set.seed (1)
cv.out = cv.glmnet(x[train ,], y[train], alpha = 1)
plot(cv.out)
bestlam = cv.out$lambda.min
bestlam
lasso.pred = predict(lasso.mod, s=bestlam, newx=x[test ,])
mean((lasso.pred - y.test)^2)
# using best subset
require(leaps)
dataBS = as.data.frame(cbind(y, x))
best.sub = regsubsets(y ~ x, data = dataBS, nvmax = nrow(coef(lasso.mod)))
best.sub.summary = summary(best.sub)
names(best.sub.summary)
# manual plotting
par(mfrow =c(2,2))
# rsq
plot(best.sub.summary$rsq , xlab="Number of Variables", ylab="Rsq", type="l")
ind_Rsq = which.max(best.sub.summary$rsq)
points(ind_Rsq, best.sub.summary$adjr2[ind_Rsq], col ="red", cex=2, pch=20)
# adjRsq
plot(best.sub.summary$adjr2 ,xlab="Number of Variables", ylab="Adjusted RSq", type="l")
ind_adjRsq = which.max(best.sub.summary$adjr2)
points(ind_adjRsq, best.sub.summary$adjr2[ind_adjRsq], col ="red", cex=2, pch=20)
# Cp
plot(best.sub.summary$cp ,xlab="Number of Variables", ylab="Cp", type="l")
ind_Cp = which.min(best.sub.summary$cp)
points(ind_Cp, best.sub.summary$cp[ind_adjRsq], col ="red", cex=2, pch=20)
# bic
plot(best.sub.summary$bic ,xlab="Number of Variables", ylab="bic", type="l")
ind_bic = which.min(best.sub.summary$bic)
points(ind_bic, best.sub.summary$bic[ind_bic], col ="red", cex=2, pch=20)
# built-in plots
?plot.regsubsets
par(mfrow=c(1,1))
plot(best.sub, scale = "r2")
plot(best.sub, scale = "adjr2")
plot(best.sub, scale = "Cp")
plot(best.sub, scale = "bic")
# retrieve the model with min BIC
coefficients(best.sub, which.min(best.sub.summary$bic))
plot(y = salary$sal_18_25, x = salary$sal_51plus)
# there is a clear outlier
ind_out = which(salary$sal_18_25 == max(salary$sal_18_25))
# check if is so in all dimensions (apparently not)
col_col <- rep("black", nrow(salary))
col_col[ind_out] <- "red"
pairs(salary[, c(3:8, 13, 18:20)], col = col_col)
# evaluate an OLS fit
fit_LM_18_25 = lm(salary$sal_18_25 ~ salary$sal_51plus)
plot(y = salary$sal_18_25, x = salary$sal_51plus)
abline(fit_LM_18_25, lwd=3, col="red")
# # using more predictors
# fit_LM_2 = lm(salary$sal_M_18_25 ~ salary$sal_26_50 + salary$sal_51plus + salary$sal_general + salary$sal_executive +
#                 salary$sal_midManager + salary$sal_employee + salary$sal_worker)
#
# summary(fit_LM_2)
# create response variable
sal_y = c(salary$sal_M_18_25, salary$sal_M_26_50, salary$sal_M_51plus,
salary$sal_M_executive, salary$sal_M_midManager, salary$sal_M_employee, salary$sal_M_worker,
salary$sal_F_18_25, salary$sal_F_26_50, salary$sal_F_51plus,
salary$sal_F_executive, salary$sal_F_midManager, salary$sal_F_employee, salary$sal_F_worker)
hist(sal_y, 30)
hist(log(sal_y), 30)
hist(sal_y^-1, 30)
sal_y = sal_y^-1  # also suggested by Box-Cox transformation
n_sal_y = length(sal_y)             # length response variable
n_cat = length(salary$sal_M_18_25)  # length of each category (i.e., original vectors)
# create sex dummy variable, 1 for males and 0 for females
sal_sex = rep(0, n_sal_y)   # full regressors
sal_sex[1:n_sal_y/2] = 1    # assign males
# create age dummy variables, 18-25 years old is the base case
sal_age = cbind(rep(0, n_sal_y), rep(0, n_sal_y)) # full regressors
# 26-50 y.o.
sal_age[(n_cat+1):(n_cat*2), 1] = 1     # males
sal_age[(n_cat*8+1):(n_cat*9), 1] = 1   # females
# 51+ y.o.
sal_age[(n_cat*2+1):(n_cat*3), 2] = 1   # males
sal_age[(n_cat*9+1):(n_cat*10), 2] = 1  # females
# create job type dummy variables, worker is the base case
sal_job = cbind(rep(0, n_sal_y), rep(0, n_sal_y), rep(0, n_sal_y)) # full regressors
# executives
sal_job[(n_cat*3+1):(n_cat*4), 1] = 1     # males
sal_job[(n_cat*10+1):(n_cat*11), 1] = 1   # females
# middle managers
sal_job[(n_cat*4+1):(n_cat*5), 2] = 1     # males
sal_job[(n_cat*11+1):(n_cat*12), 2] = 1   # females
# employee
sal_job[(n_cat*5+1):(n_cat*6), 3] =   1   # males
sal_job[(n_cat*12+1):(n_cat*13), 3] = 1   # females
# final data set
data_ANOVA = cbind.data.frame(response = sal_y, sex = sal_sex, age = sal_age, job = sal_job)
names(data_ANOVA)
# show regressors' shape
if(!require(rafalib)){install.packages("rafalib")}
imagemat(data_ANOVA[,-1])
# ANOVA model
sal_ANOVA = lm(sal_y ~ sal_sex + sal_age + sal_job + sal_sex:sal_age + sal_sex:sal_job)
summary(sal_ANOVA)
anova((sal_ANOVA))
# box-cox transformation suggested to use y^-1
if(!require(MASS)){install.packages("MASS")}
boxcox(sal_ANOVA)
# adding contrasts?
# add CV and LASSO!
myPr <- prcomp(salary[, 3:26], scale = TRUE)
myPr
summary(myPr)
plot(myPr, type = "l")
biplot(myPr, scale = 0, cex = 0.5)
str(myPr)
#myPr$x #checking principal component scores
salary2 <- cbind(salary, myPr$x[, 1:2])
head(salary2)
#plot with ggplot...
#require(ggplot2)
ggplot(salary2, aes(PC1, PC2)) +
stat_ellipse(geom = "polygon", col = "black", alpha = 0.5) +
geom_point(shape = 21, col = "black")
# correlations between variables and PCs...
cor(salary[, 3:26], salary2[,27:28])
# preliminary checks
names(population)
summary(population)
# Drop unnecessary columns (NIVGEO is the same for all)
population <- subset(population, select = -c(NIVGEO, LIBGEO))
# converting CODGEO to numeric
population$CODGEO <- as.numeric(population$CODGEO)
# Refactor sex and MOCO
population$MOCO <- factor(population$MOCO, levels = c(11,12,21,22,23,31,32),
labels = c("children_living_with_two_parents", "children living with one parent",
"adults_living_in_couple_without_child", "adults_living_in_couple_with_children",
"adults_living_alone_with_children","persons not from family living in the home",
"persons_living_alone"))
population$sex <- factor(population$sex, levels = c(1,2), labels = c("Male", "Female"))
head(population)
# Take out rows with NB (number of people in this category) equal to 0
population <- population[population$peopleCategNum != 0,]
head(population)
summary(population)
#Compare age categories:
#library(ggplot2)
#  number of units
n_cat <- length(population$CODGEO)
# extract unique categories
uniq_cat <- unique(population$ageCateg5!=5)
# vector representing sex for each category
Label <- c(rep(c('Male', 'Female'), n_cat))
# vector representing the variable considered
Variable <- rep(uniq_cat, n_cat/length(uniq_cat))
Value=population$peopleCategNum
# merge these data
#pop_categ = cbind.data.frame(Label = Label,
#             value = Value,
#             Variable = Variable)
#p <- ggplot(data = pop_categ, aes(x=Label, y=value))
#p <- p + geom_boxplot(aes(fill = Label))
# if you want color for points replace group with colour=Label
#p <- p + geom_point(aes(y=value, colour=Label), position = position_dodge(width=0.75))
#p <- p + facet_wrap( ~ Variable, scales="free")
#p <- p + xlab("x-axis") + ylab("y-axis") + ggtitle("Category comparison")
# p <- p + guides(fill=guide_legend(title="Legend"))
#p
# Restructure population data to produce the demographic profile per town
# install.packages("plyr")
library(plyr)
population_per_town_data <- ddply(population, .(CODGEO), function(population) {
data.frame(total_population = sum(population$peopleCategNum),
male = sum(population[population$sex == "Male",]$peopleCategNum),
female = sum(population[population$sex == "Female",]$peopleCategNum),
child = sum(population[population$ageCateg5 %in% seq(0, 10, by=5),]$peopleCategNum),
elderly = sum(population[population$ageCateg5 %in% seq(65, 80, by=5),]$peopleCategNum),
workforce = sum(population[population$ageCateg5 %in% seq(15, 60, by=5),]$peopleCategNum)
)})
population_per_town_data$dependent <- population_per_town_data$child + population_per_town_data$elderly
population_per_town_data$sex_ratio <- ifelse(population_per_town_data$female==0, 0, population_per_town_data$male / population_per_town_data$female)
population_per_town_data$dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$dependent / population_per_town_data$workforce)
population_per_town_data$aged_dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$elderly / population_per_town_data$workforce)
population_per_town_data$child_dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$child / population_per_town_data$workforce)
summary(population_per_town_data)
# Scale population to log
hist(population_per_town_data$total_population, ylim=c(0,40000), breaks = seq(0, 2500000, by=250000), xlab="", main = "", labels=T, col ="light blue")
population_per_town_data$total_population_log <- log10(population_per_town_data$total_population)
# Merge geo and pop
geo_pop_by_town <- merge(geo, population_per_town_data)
summary(geo_pop_by_town)
# Plot "Distribution of Population for each Town"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$total_population_log), max(geo_pop_by_town$total_population_log)))
poppulation_distribution <-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$total_population_log),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_town, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each Town")
poppulation_distribution
# Group population data by department because of small size of some towns and the given geojson file of department
pop_by_department <- ddply(geo_pop_by_town, .(department), function(geo_pop_by_town) {
data.frame(total_population = sum(geo_pop_by_town$total_population),
male = sum(geo_pop_by_town$male),
female = sum(geo_pop_by_town$female),
child = sum(geo_pop_by_town$child),
elderly = sum(geo_pop_by_town$elderly),
dependent = sum(geo_pop_by_town$dependent),
workforce = sum(geo_pop_by_town$workforce)
)})
summary(pop_by_department)
pop_by_department$dependency_ratio <- pop_by_department$dependent / pop_by_department$workforce
pop_by_department$aged_dependency_ratio <- pop_by_department$elderly / pop_by_department$workforce
pop_by_department$child_dependency_ratio <- pop_by_department$child / pop_by_department$workforce
# Scale population to log
pop_by_department$total_population_log <- log10(pop_by_department$total_population)
# Merge geo and pop
geo_pop_by_department <- merge(geo, pop_by_department)
summary(geo_pop_by_department)
# Plot "Distribution of Population for each department"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_department$total_population_log), max(geo_pop_by_department$total_population_log)))
pop_distribution_department <-
FraMap +
geom_point(aes(x=geo_pop_by_department$longitude, y=geo_pop_by_department$latitude, colour=geo_pop_by_department$total_population_log),
data=geo_pop_by_department, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_department, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each department")
pop_distribution_department
# use only integer values
geo$CODGEO = as.integer(geo$CODGEO)  # already integer
population$CODGEO = as.integer(population$CODGEO)
firms$CODGEO = as.integer(firms$CODGEO)
salary$CODGEO = as.integer(salary$CODGEO)
# install.packages("dplyr")
library(dplyr)
dataset = c("population", "salary", "firms", "geo")
# obtain sommon IDs for all datasets
for (i in dataset){
# get i-th name and make a new variable adding NEW
nam <- paste(i, "NEW", sep = "")
# counter to identify the number of iteration in j
iter = 1
for (j in dataset){
if (j != i){
# datasets different from i-th
if (iter == 1){
# 1st iteration: use the original dataset (e.g., geo)
assign(nam, semi_join(get(i), get(j), by = "CODGEO"))
} else{
# successive iteration: use the new dataset (e.g., geoNEW)
assign(nam, semi_join(get(nam), get(j), by = "CODGEO"))
}
iter = iter + 1
}
}
}
# check how many observation have been deleted
for (i in dataset){
del_rows = nrow(get(i)) - nrow(get(paste(i, "NEW", sep = "")))
del_prop = del_rows / nrow(get(paste(i, "NEW", sep = "")))
del_obs = paste("For", i, del_rows, "have been deleted.",
"They were the", round(del_prop, digits=2), "% of the total.", sep = " ")
print(del_obs)
}
#populationNEW
summary(populationNEW)
population = populationNEW
# Restructure population data to produce the demographic profile per town
# install.packages("plyr")
library(plyr)
library(dplyr)
population_per_town_data <- ddply(population, .(CODGEO), function(population) {
data.frame(total_population = sum(population$peopleCategNum),
male = sum(population[population$sex == "Male",]$peopleCategNum),
female = sum(population[population$sex == "Female",]$peopleCategNum),
child = sum(population[population$ageCateg5 %in% seq(0, 10, by=5),]$peopleCategNum),
elderly = sum(population[population$ageCateg5 %in% seq(65, 80, by=5),]$peopleCategNum),
workforce = sum(population[population$ageCateg5 %in% seq(15, 60, by=5),]$peopleCategNum)
)})
population_per_town_data$dependent <- population_per_town_data$child + population_per_town_data$elderly
population_per_town_data$sex_ratio <- ifelse(population_per_town_data$female==0, 0, population_per_town_data$male / population_per_town_data$female)
population_per_town_data$dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$dependent / population_per_town_data$workforce)
population_per_town_data$aged_dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$elderly / population_per_town_data$workforce)
population_per_town_data$child_dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$child / population_per_town_data$workforce)
summary(population_per_town_data)
# Scale population to log
hist(population_per_town_data$total_population, ylim=c(0,40000), breaks = seq(0, 2500000, by=250000), xlab="", main = "", labels=T, col ="light blue")
population_per_town_data$total_population_log <- log10(population_per_town_data$total_population)
# Merge geo and pop
geo_pop_by_town <- merge(geo, population_per_town_data)
summary(geo_pop_by_town)
# Plot "Distribution of Population for each Town"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$total_population_log), max(geo_pop_by_town$total_population_log)))
population_distribution <-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$total_population_log),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_town, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each Town")
population_distribution
summary(population_distribution)
geo_pop_by_town[which.max(geo_pop_by_town$total_population_log),]
# Group population data by department because of small size of some towns and the given geojson file of department
pop_by_department <- ddply(geo_pop_by_town, .(department), function(geo_pop_by_town) {
data.frame(total_population = sum(geo_pop_by_town$total_population),
male = sum(geo_pop_by_town$male),
female = sum(geo_pop_by_town$female),
child = sum(geo_pop_by_town$child),
elderly = sum(geo_pop_by_town$elderly),
dependent = sum(geo_pop_by_town$dependent),
workforce = sum(geo_pop_by_town$workforce)
)})
summary(pop_by_department)
pop_by_department$dependency_ratio <- pop_by_department$dependent / pop_by_department$workforce
pop_by_department$aged_dependency_ratio <- pop_by_department$elderly / pop_by_department$workforce
pop_by_department$child_dependency_ratio <- pop_by_department$child / pop_by_department$workforce
# Scale population to log
pop_by_department$total_population_log <- log10(pop_by_department$total_population)
# Merge geo and pop
geo_pop_by_department <- merge(geo, pop_by_department)
summary(geo_pop_by_department)
# Plot "Distribution of Population for each department"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_department$total_population_log), max(geo_pop_by_department$total_population_log)))
pop_distribution_department <-
FraMap +
geom_point(aes(x=geo_pop_by_department$longitude, y=geo_pop_by_department$latitude, colour=geo_pop_by_department$total_population_log),
data=geo_pop_by_department, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_department, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each department")
pop_distribution_department
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) +
labs(y = "Population") +
coord_flip()
print(pop_pyramid)
View(geoNEW)
unique(salary$CODGEO) == unique(geo$CODGEO)
sum((unique(salary$CODGEO) == unique(geo$CODGEO)) == 0)
#install.packages("ggplot2")
#install.packages("ggmap")
require(ggplot2)
require(ggmap)
# plot france (center: 2.213749 46.227638)
# fra_center = as.numeric(geocode("France"))
fra_center = c(2.213749, 46.227638)
FraMap = ggmap(get_googlemap(center=fra_center, scale=2, zoom=5), extent="normal")
FraMap
# plot all towns available
geo_pos = as.data.frame(cbind(lon = geo$longitude, lat = geo$latitude))
geo_pos = geo_pos[complete.cases(geo_pos),]
FraMap +
geom_point(aes(x=lon, y=lat), data=geo_pos, col="orange", alpha=0.8, size=0.6)
# delete non-European countries
ind_nonEur = geo$latitude < 30 | geo$latitude > 70 |geo$longitude < -20 | geo$longitude > 20
sum(ind_nonEur)
geo = geo[!ind_nonEur,]
# plot all European towns available
geo_pos = as.data.frame(cbind(lon = geo$longitude, lat = geo$latitude))
geo_pos = geo_pos[complete.cases(geo_pos),]
FraMap +
geom_point(aes(x=lon, y=lat), data=geo_pos, col="orange", alpha=0.8, size=0.6)
#install.packages("ggplot2")
#install.packages("ggmap")
require(ggplot2)
require(ggmap)
# plot france (center: 2.213749 46.227638)
# fra_center = as.numeric(geocode("France"))
fra_center = c(2.213749, 46.227638)
FraMap = ggmap(get_googlemap(center=fra_center, scale=2, zoom=5), extent="normal")
FraMap
# plot all towns available
geo_pos = as.data.frame(cbind(lon = geo$longitude, lat = geo$latitude))
geo_pos = geo_pos[complete.cases(geo_pos),]
FraMap +
geom_point(aes(x=lon, y=lat), data=geo_pos, col="orange", alpha=0.8, size=0.6)
# delete non-European countries
ind_nonEur = geo$latitude < 30 | geo$latitude > 70 |geo$longitude < -20 | geo$longitude > 20
sum(ind_nonEur)
geo = geo[!ind_nonEur,]
# plot all European towns available
geo_pos = as.data.frame(cbind(lon = geo$longitude, lat = geo$latitude))
geo_pos = geo_pos[complete.cases(geo_pos),]
FraMap +
geom_point(aes(x=lon, y=lat), data=geo_pos, col="orange", alpha=0.8, size=0.6)
# plot france (center: 2.213749 46.227638)
# fra_center = as.numeric(geocode("France"))
fra_center = c(2.213749, 46.227638)
FraMap = ggmap(get_googlemap(center=fra_center, scale=2, zoom=5), extent="normal")
FraMap
# plot all towns available
geo_pos = as.data.frame(cbind(lon = geo$longitude, lat = geo$latitude))
geo_pos = geo_pos[complete.cases(geo_pos),]
FraMap +
geom_point(aes(x=lon, y=lat), data=geo_pos, col="orange", alpha=0.8, size=0.6)
# delete non-European countries
ind_nonEur = geo$latitude < 30 | geo$latitude > 70 |geo$longitude < -20 | geo$longitude > 20
sum(ind_nonEur)
geo = geo[!ind_nonEur,]
# plot all European towns available
geo_pos = as.data.frame(cbind(lon = geo$longitude, lat = geo$latitude))
geo_pos = geo_pos[complete.cases(geo_pos),]
FraMap +
geom_point(aes(x=lon, y=lat), data=geo_pos, col="orange", alpha=0.8, size=0.6)
population[population$sex == "Male",]$peopleCategNum == population$peopleCategNum[population$sex == "Male",])
population[population$sex == "Male",]$peopleCategNum == population$peopleCategNum[population$sex == "Male",]
sum(population[population$sex == "Male",])
count(population[population$sex == "Male",])
count(population[population$sex == "Male",])
count(population[population$sex == "Male",1])
count(population[population$sex == "Male",])
dim(population[population$sex == "Male",])
dim(data.frame(total_population = sum(population$peopleCategNum),
male = sum(population[population$sex == "Male",]$peopleCategNum),
female = sum(population[population$sex == "Female",]$peopleCategNum),
child = sum(population[population$ageCateg5 %in% seq(0, 10, by=5),]$peopleCategNum),
elderly = sum(population[population$ageCateg5 %in% seq(65, 80, by=5),]$peopleCategNum),
workforce = sum(population[population$ageCateg5 %in% seq(15, 60, by=5),]$peopleCategNum) )
)
head(data.frame(total_population = sum(population$peopleCategNum),
male = sum(population[population$sex == "Male",]$peopleCategNum),
female = sum(population[population$sex == "Female",]$peopleCategNum),
child = sum(population[population$ageCateg5 %in% seq(0, 10, by=5),]$peopleCategNum),
elderly = sum(population[population$ageCateg5 %in% seq(65, 80, by=5),]$peopleCategNum),
workforce = sum(population[population$ageCateg5 %in% seq(15, 60, by=5),]$peopleCategNum) )
)
34065*5023
# options(encoding = "UTF-8")  # for Mac [PROBABLY, to check]
# options(encoding = "ISO-8859-1")  # for Windows [PROBABLY NOT WORKING]
setwd("./data")
firms       <- read.csv("base_etablissement_par_tranche_effectif.csv", encoding = "UTF-8")
geo         <- read.csv("name_geographic_information.csv", encoding = "UTF-8")
salary      <- read.csv("net_salary_per_town_categories.csv", encoding = "UTF-8")
population  <- read.csv("population.csv", encoding = "UTF-8")
# options(encoding = "UTF-8")  # for Mac [PROBABLY, to check]
# options(encoding = "ISO-8859-1")  # for Windows [PROBABLY NOT WORKING]
setwd("./data")
firms       <- read.csv("base_etablissement_par_tranche_effectif.csv", encoding = "UTF-8")
geo         <- read.csv("name_geographic_information.csv", encoding = "UTF-8")
salary      <- read.csv("net_salary_per_town_categories.csv", encoding = "UTF-8")
population  <- read.csv("population.csv", encoding = "UTF-8")
# options(encoding = "UTF-8")  # for Mac [PROBABLY, to check]
# options(encoding = "ISO-8859-1")  # for Windows [PROBABLY NOT WORKING]
setwd("./data")
firms       <- read.csv("base_etablissement_par_tranche_effectif.csv", encoding = "UTF-8")
geo         <- read.csv("name_geographic_information.csv", encoding = "UTF-8")
salary      <- read.csv("net_salary_per_town_categories.csv", encoding = "UTF-8")
population  <- read.csv("population.csv", encoding = "UTF-8")
