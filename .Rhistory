<<<<<<< Updated upstream
rep("MidManager", n_sex),
rep("Employee", n_sex),
rep("Worker",n_sex))
# merge these data
sal_sex = cbind.data.frame(Label = Label,
value = c(salary$sal_Males, salary$sal_M_executive, salary$sal_M_midManager, salary$sal_M_employee, salary$sal_M_worker,
salary$sal_Females, salary$sal_F_executive, salary$sal_F_midManager, salary$sal_F_employee, salary$sal_F_worker),
Variable = Variable)
# plotting phase
p <-  ggplot(data = sal_sex, aes(x=Label, y=value)) +
geom_boxplot(aes(fill = Label)) +
# not color points replacing colour = group instead of colour=Label
geom_point(aes(y=value, colour=Label), position = position_dodge(width=0.75)) +
facet_wrap( ~ Variable, scales="free") +
xlab("Sex") + ylab("Mean net salary per hour") + ggtitle("Gender comparison for different job positions") +
theme(plot.title = element_text(hjust = 0.5)) +
stat_boxplot(geom = "errorbar", width = 0.5)
# p <- p + guides(fill=guide_legend(title="Legend"))
p
# excluding outliers
p <- ggplot(data = sal_sex, aes(x=Label, y=value)) +
scale_y_continuous(limits = quantile(sal_sex$value, c(0, 0.9))) +
geom_boxplot(aes(fill = Label)) +
# not color points replacing colour = group instead of colour=Label
geom_point(aes(y=value, colour=Label), position = position_dodge(width=0.75)) +
facet_wrap( ~ Variable, scales="free") +
xlab("Sex") + ylab("Mean net salary per hour") +
ggtitle("Gender comparison for different job positions excluding the last decile") +
theme(plot.title = element_text(hjust = 0.5)) +
# p <- p + guides(fill=guide_legend(title="Legend"))
stat_boxplot(geom = "errorbar", width = 0.5)
p
# vector representing males and females
Label <- c(rep("M", n_sex*3), rep("F", n_sex*3))
# vector representing the variable considered
Variable <- c(rep("18-25", n_sex),
rep("26-50", n_sex),
rep("51+", n_sex),
rep("18-25", n_sex),
rep("26-50", n_sex),
rep("51+", n_sex))
# merge these data
sal_sex = cbind.data.frame(Label = Label,
value = c(salary$sal_M_18_25, salary$sal_M_26_50, salary$sal_M_51plus,
salary$sal_F_18_25, salary$sal_F_26_50, salary$sal_F_51plus),
Variable = Variable)
# plotting phase
p <-  ggplot(data = sal_sex, aes(x=Label, y=value)) +
geom_boxplot(aes(fill = Label)) +
# not color points replacing colour = group instead of colour=Label
geom_point(aes(y=value, colour=Label), position = position_dodge(width=0.75)) +
facet_wrap( ~ Variable, scales="free") +
xlab("Sex") + ylab("Mean net salary per hour") + ggtitle("Gender comparison for different ages") +
theme(plot.title = element_text(hjust = 0.5)) + ylim(c(5, 100)) +
stat_boxplot(geom = "errorbar", width = 0.5)
# p <- p + guides(fill=guide_legend(title="Legend"))
p
# Gender salary ratio and general level of income
# Overall mean salary
# The higher the net mean income, the more skewed the ratio of salary between female and male is.
# only 2 towns have a ratio>1
salary$salary_ratio_FvsM <- salary$sal_Females / salary$sal_Males
hist(salary$salary_ratio_FvsM)
ggplot(salary, aes(x= sal_general, y=salary_ratio_FvsM)) +
geom_point(size = 0.5, colour = "#0091ff")+
geom_smooth()
# Executives mean salary
# a bit better and less skewed
salary$salary_ratio_FvsM_Exec <- salary$sal_F_executive / salary$sal_M_executive
hist(salary$salary_ratio_FvsM_Exec)
ggplot(salary, aes(x= sal_general, y= salary_ratio_FvsM_Exec)) +
geom_point(size = 0.5, colour = "#0091ff")+
geom_smooth()
# Middle managers mean salary
# ..
salary$salary_ratio_FvsM_midManag <- salary$sal_F_midManager / salary$sal_M_midManager
hist(salary$salary_ratio_FvsM_midManag)
ggplot(salary, aes(x= sal_general, y= salary_ratio_FvsM_midManag)) +
geom_point(size = 0.5, colour = "#0091ff")+
geom_smooth()
# Middle managers mean salary
# ..
salary$salary_ratio_FvsM_worker <- salary$sal_F_worker / salary$sal_M_worker
hist(salary$salary_ratio_FvsM_worker)
ggplot(salary, aes(x= sal_general, y= salary_ratio_FvsM_worker)) +
geom_point(size = 0.5, colour = "#0091ff")+
geom_smooth()
# Employee mean salary
# ..
salary$salary_ratio_FvsM_employee <- salary$sal_F_employee / salary$sal_M_employee
hist(salary$salary_ratio_FvsM_employee)
ggplot(salary, aes(x= sal_general, y= salary_ratio_FvsM_employee)) +
geom_point(size = 0.5, colour = "#0091ff")+
geom_smooth()
# most general pairs
pairs(salary[c(3:8, 13, 18:20)])
# pairs highlighting genders' differences
pairs(salary[c(9:12, 14:17)])
# fit and show OLS estimate
plot(salary$sal_26_50 ~ salary$sal_51plus)
fit_LM_26_50 = glm(salary$sal_26_50 ~ salary$sal_51plus, data = salary)
abline(fit_LM_26_50, lwd=3, col="red")
# diagnostics
summary(fit_LM_26_50)
plot(fit_LM_26_50)
require(boot)
set.seed(1)
# k-Fold Cross-Validation
cv.err.K = rep(0, 5)
cv.err.K = rbind(cv.err.K, cv.err.K)
for (i in 1:5){
fit_LM_26_50.K = glm(sal_26_50 ~ poly(sal_51plus, i), data = salary)
cv.err.K[,i] = cv.glm(salary, fit_LM_26_50.K, K = 10)$delta[1]
}
# plotting results
plot(cv.err.K[1,], type = 'l', col = 'red', xlab = "Polynomials' order",
ylab = "10-folds CV", main = "CV and adjusted CV for different polynomials")
lines(cv.err.K[2,], col = 'green')
points(which.min(cv.err.K), cv.err.K[1, which.min(cv.err.K)], col = "red", cex=2, pch=20)
legend('topright', legend = c('CV', 'Adj. CV'), col = c('red', 'green'), pch = 10)
require(glmnet)
set.seed(1)
# crate an X matrix excluding intercept
# x = cbind(salary$sal_midManager, salary$sal_employee, salary$sal_worker, salary$sal_18_25, salary$sal_51plus)
# y = salary$sal_executive
# probably for ridge
names(salary)
y = salary$sal_26_50
x = as.matrix(cbind(salary[, c(4:8, 13, 18, 20)]))
names(x)
# grid for lambda values
grid = 10^seq(1, -5, length = 100)
lasso.mod = glmnet(x, y, alpha = 1, lambda = grid)
dim(coef(lasso.mod))
# the norms are increasing in value because of the shrinkage
lasso.mod$lambda[1]                  # lambda value
sqrt(sum(coef(lasso.mod)[-1,1]^2))   # L2 norm of its coeff
lasso.mod$lambda[51]
sqrt(sum(coef(lasso.mod)[-1,51]^2))
lasso.mod$lambda[90]
sqrt(sum(coef(lasso.mod)[-1,90]^2))
# predict values for a new lambda, e.g. OLS
OLS = predict(lasso.mod, s = 0, type = "coefficients")[1:nrow(coef(lasso.mod)),]
# split the date leaving the 10% for CV
train = sample(1:nrow(salary), floor(nrow(salary)*0.9))
test = -train
y.test = y[test]
lasso.mod = glmnet(x[train,], y[train], alpha = 1, lambda = grid, thresh = 1e-12)
err.i = rep("NA", length(grid))
for (i in 1:length(grid)){
lasso.pred = predict(lasso.mod, s = grid[i], newx = x[test,])
err.i[i] = mean((lasso.pred - y.test)^2)
}
plot(log(grid), err.i, xlab = 'log Lambda', ylab = 'test set MSE',
main = 'Test MSE among different Lambdas', ylim = c(0, 10))
bestlam = grid[which.min(err.i)]
points(log(grid)[bestlam], err.i[bestlam], col ="red", cex=2, pch=20)
# high values of lambda are like fitting just the intercept
# using 10 folds CV
set.seed (1)
cv.out = cv.glmnet(x[train ,], y[train], alpha = 1)
plot(cv.out)
bestlam = cv.out$lambda.min
bestlam
lasso.pred = predict(lasso.mod, s=bestlam, newx=x[test ,])
mean((lasso.pred - y.test)^2)
# using best subset
require(leaps)
dataBS = as.data.frame(cbind(y, x))
best.sub = regsubsets(y ~ x, data = dataBS, nvmax = nrow(coef(lasso.mod)))
best.sub.summary = summary(best.sub)
names(best.sub.summary)
# manual plotting
par(mfrow =c(2,2))
# rsq
plot(best.sub.summary$rsq , xlab="Number of Variables", ylab="Rsq", type="l")
ind_Rsq = which.max(best.sub.summary$rsq)
points(ind_Rsq, best.sub.summary$adjr2[ind_Rsq], col ="red", cex=2, pch=20)
# adjRsq
plot(best.sub.summary$adjr2 ,xlab="Number of Variables", ylab="Adjusted RSq", type="l")
ind_adjRsq = which.max(best.sub.summary$adjr2)
points(ind_adjRsq, best.sub.summary$adjr2[ind_adjRsq], col ="red", cex=2, pch=20)
# Cp
plot(best.sub.summary$cp ,xlab="Number of Variables", ylab="Cp", type="l")
ind_Cp = which.min(best.sub.summary$cp)
points(ind_Cp, best.sub.summary$cp[ind_adjRsq], col ="red", cex=2, pch=20)
# bic
plot(best.sub.summary$bic ,xlab="Number of Variables", ylab="bic", type="l")
ind_bic = which.min(best.sub.summary$bic)
points(ind_bic, best.sub.summary$bic[ind_bic], col ="red", cex=2, pch=20)
# built-in plots
?plot.regsubsets
par(mfrow=c(1,1))
plot(best.sub, scale = "r2")
plot(best.sub, scale = "adjr2")
plot(best.sub, scale = "Cp")
plot(best.sub, scale = "bic")
# retrieve the model with min BIC
coefficients(best.sub, which.min(best.sub.summary$bic))
# create response variable
sal_y = c(salary$sal_M_18_25, salary$sal_M_26_50, salary$sal_M_51plus,
salary$sal_M_executive, salary$sal_M_midManager, salary$sal_M_employee, salary$sal_M_worker,
salary$sal_F_18_25, salary$sal_F_26_50, salary$sal_F_51plus,
salary$sal_F_executive, salary$sal_F_midManager, salary$sal_F_employee, salary$sal_F_worker)
hist(sal_y, 30)
hist(log(sal_y), 30)
hist(sal_y^-1, 30)
sal_y = sal_y^-1  # also suggested by Box-Cox transformation
n_sal_y = length(sal_y)             # length response variable
n_cat = length(salary$sal_M_18_25)  # length of each category (i.e., original vectors)
# create sex dummy variable, 1 for males and 0 for females
sal_sex = rep(0, n_sal_y)   # full regressors
sal_sex[1:n_sal_y/2] = 1    # assign males
# create age dummy variables, 18-25 years old is the base case
sal_age = cbind(rep(0, n_sal_y), rep(0, n_sal_y)) # full regressors
# 26-50 y.o.
sal_age[(n_cat+1):(n_cat*2), 1] = 1     # males
sal_age[(n_cat*8+1):(n_cat*9), 1] = 1   # females
# 51+ y.o.
sal_age[(n_cat*2+1):(n_cat*3), 2] = 1   # males
sal_age[(n_cat*9+1):(n_cat*10), 2] = 1  # females
# create job type dummy variables, worker is the base case
sal_job = cbind(rep(0, n_sal_y), rep(0, n_sal_y), rep(0, n_sal_y)) # full regressors
# executives
sal_job[(n_cat*3+1):(n_cat*4), 1] = 1     # males
sal_job[(n_cat*10+1):(n_cat*11), 1] = 1   # females
# middle managers
sal_job[(n_cat*4+1):(n_cat*5), 2] = 1     # males
sal_job[(n_cat*11+1):(n_cat*12), 2] = 1   # females
# employee
sal_job[(n_cat*5+1):(n_cat*6), 3] =   1   # males
sal_job[(n_cat*12+1):(n_cat*13), 3] = 1   # females
# final data set
data_ANOVA = cbind.data.frame(response = sal_y, sex = sal_sex, age = sal_age, job = sal_job)
names(data_ANOVA)
# show regressors' shape
if(!require(rafalib)){install.packages("rafalib")}
imagemat(data_ANOVA[,-1])
=======
>>>>>>> Stashed changes
# ANOVA model
sal_ANOVA = lm(sal_y ~ sal_sex + sal_age + sal_job + sal_sex:sal_age + sal_sex:sal_job)
summary(sal_ANOVA)
anova((sal_ANOVA))
# box-cox transformation suggested to use y^-1
if(!require(MASS)){install.packages("MASS")}
boxcox(sal_ANOVA)
# adding contrasts?
# add CV and LASSO!
myPr <- prcomp(salary[, 3:26], scale = TRUE)
myPr
summary(myPr)
plot(myPr, type = "l")
biplot(myPr, scale = 0, cex = 0.5)
str(myPr)
#myPr$x #checking principal component scores
salary2 <- cbind(salary, myPr$x[, 1:2])
head(salary2)
#plot with ggplot...
#require(ggplot2)
ggplot(salary2, aes(PC1, PC2)) +
stat_ellipse(geom = "polygon", col = "black", alpha = 0.5) +
geom_point(shape = 21, col = "black")
# correlations between variables and PCs...
cor(salary[, 3:26], salary2[,27:28])
# preliminary checks
names(population)
summary(population)
# Drop unnecessary columns (NIVGEO is the same for all)
population <- subset(population, select = -c(NIVGEO, LIBGEO))
# converting CODGEO to numeric
population$CODGEO <- as.numeric(population$CODGEO)
# Refactor sex and MOCO
population$MOCO <- factor(population$MOCO, levels = c(11,12,21,22,23,31,32),
labels = c("children_living_with_two_parents", "children living with one parent",
"adults_living_in_couple_without_child", "adults_living_in_couple_with_children",
"adults_living_alone_with_children","persons not from family living in the home",
"persons_living_alone"))
population$sex <- factor(population$sex, levels = c(1,2), labels = c("Male", "Female"))
head(population)
# Take out rows with NB (number of people in this category) equal to 0
population <- population[population$peopleCategNum != 0,]
head(population)
summary(population)
#Compare age categories:
#library(ggplot2)
#  number of units
n_cat <- length(population$CODGEO)
# extract unique categories
uniq_cat <- unique(population$ageCateg5!=5)
# vector representing sex for each category
Label <- c(rep(c('Male', 'Female'), n_cat))
# vector representing the variable considered
Variable <- rep(uniq_cat, n_cat/length(uniq_cat))
Value=population$peopleCategNum
# merge these data
#pop_categ = cbind.data.frame(Label = Label,
#             value = Value,
#             Variable = Variable)
#p <- ggplot(data = pop_categ, aes(x=Label, y=value))
#p <- p + geom_boxplot(aes(fill = Label))
# if you want color for points replace group with colour=Label
#p <- p + geom_point(aes(y=value, colour=Label), position = position_dodge(width=0.75))
#p <- p + facet_wrap( ~ Variable, scales="free")
#p <- p + xlab("x-axis") + ylab("y-axis") + ggtitle("Category comparison")
# p <- p + guides(fill=guide_legend(title="Legend"))
#p
# Restructure population data to produce the demographic profile per town
# install.packages("plyr")
library(plyr)
population_per_town_data <- ddply(population, .(CODGEO), function(population) {
data.frame(total_population = sum(population$peopleCategNum),
male = sum(population[population$sex == "Male",]$peopleCategNum),
female = sum(population[population$sex == "Female",]$peopleCategNum),
child = sum(population[population$ageCateg5 %in% seq(0, 10, by=5),]$peopleCategNum),
elderly = sum(population[population$ageCateg5 %in% seq(65, 80, by=5),]$peopleCategNum),
workforce = sum(population[population$ageCateg5 %in% seq(15, 60, by=5),]$peopleCategNum)
)})
population_per_town_data$dependent <- population_per_town_data$child + population_per_town_data$elderly
population_per_town_data$sex_ratio <- ifelse(population_per_town_data$female==0, 0, population_per_town_data$male / population_per_town_data$female)
population_per_town_data$dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$dependent / population_per_town_data$workforce)
population_per_town_data$aged_dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$elderly / population_per_town_data$workforce)
population_per_town_data$child_dependency_ratio <- ifelse(population_per_town_data$workforce==0, 0, population_per_town_data$child / population_per_town_data$workforce)
summary(population_per_town_data)
# Scale population to log
hist(population_per_town_data$total_population, ylim=c(0,40000), breaks = seq(0, 2500000, by=250000), xlab="", main = "", labels=T, col ="light blue")
population_per_town_data$total_population_log <- log10(population_per_town_data$total_population)
# Merge geo and pop
geo_pop_by_town <- merge(geo, population_per_town_data)
summary(geo_pop_by_town)
# Plot "Distribution of Population for each Town"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$total_population_log), max(geo_pop_by_town$total_population_log)))
poppulation_distribution <-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$total_population_log),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_town, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each Town")
poppulation_distribution
# Group population data by department because of small size of some towns and the given geojson file of department
pop_by_department <- ddply(geo_pop_by_town, .(department), function(geo_pop_by_town) {
data.frame(total_population = sum(geo_pop_by_town$total_population),
male = sum(geo_pop_by_town$male),
female = sum(geo_pop_by_town$female),
child = sum(geo_pop_by_town$child),
elderly = sum(geo_pop_by_town$elderly),
dependent = sum(geo_pop_by_town$dependent),
workforce = sum(geo_pop_by_town$workforce)
)})
summary(pop_by_department)
pop_by_department$dependency_ratio <- pop_by_department$dependent / pop_by_department$workforce
pop_by_department$aged_dependency_ratio <- pop_by_department$elderly / pop_by_department$workforce
pop_by_department$child_dependency_ratio <- pop_by_department$child / pop_by_department$workforce
# Scale population to log
pop_by_department$total_population_log <- log10(pop_by_department$total_population)
# Merge geo and pop
geo_pop_by_department <- merge(geo, pop_by_department)
summary(geo_pop_by_department)
# Plot "Distribution of Population for each department"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_department$total_population_log), max(geo_pop_by_department$total_population_log)))
pop_distribution_department <-
FraMap +
geom_point(aes(x=geo_pop_by_department$longitude, y=geo_pop_by_department$latitude, colour=geo_pop_by_department$total_population_log),
data=geo_pop_by_department, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_department, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each department")
pop_distribution_department
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of population") + theme(plot.title = element_text(hjust = 0.5)) + labs(y = "Population") +
coord_flip()
print(pop_pyramid)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Female",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of population") + theme(plot.title = element_text(hjust = 0.5)) + labs(y = "Population") +
coord_flip()
print(pop_pyramid)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of population") + theme(plot.title = element_text(hjust = 0.5)) + labs(y = "Population") +
coord_flip()
print(pop_pyramid)
which(geo_pop_by_town$dependency_ratio, geo_pop_by_town$town_name =0)
geo_pop_by_town$town_name(geo_pop_by_town$dependency_ratio)=0
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$aged_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$aged_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$aged_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, ... =   colour=geo_pop_by_town$aged_dependency_ratio), data=geo_pop_by_town, alpha=0.8, size=0.6) +
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$aged_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, ... = colour=geo_pop_by_town$aged_dependency_ratio), data=geo_pop_by_town, alpha=0.8, size=0.6) +
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$aged_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$aged_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$aged_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$age_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour = geo_pop_by_town$age_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude,
colour =geo_pop_by_town$age_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude,
colour =geo_pop_by_town$age_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude,colour=geo_pop_by_town$aged_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude,y=geo_pop_by_town$latitude,colour=geo_pop_by_town$aged_dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$age_dependency_ratio), max(geo_pop_by_town$age_dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude,y=geo_pop_by_town$latitude,colour=geo_pop_by_town$aged_dependency_ratio), data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(4)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow()), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(1)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(1)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(2)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of population") + theme(plot.title = element_text(hjust = 0.5)) + labs(y = "Population") +
coord_flip()
print(pop_pyramid)
# Plot "Distribution of Population for each department"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_department$total_population_log), max(geo_pop_by_department$total_population_log)))
pop_distribution_department <-
FraMap +
geom_point(aes(x=geo_pop_by_department$longitude, y=geo_pop_by_department$latitude, colour=geo_pop_by_department$total_population_log),
data=geo_pop_by_department, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_department, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each department")
pop_distribution_department
# Scale population to log
hist(population_per_town_data$total_population, ylim=c(0,40000), breaks = seq(0, 2500000, by=250000), xlab="", main = "", labels=T, col ="light blue")
population_per_town_data$total_population_log <- log10(population_per_town_data$total_population)
# Merge geo and pop
geo_pop_by_town <- merge(geo, population_per_town_data)
summary(geo_pop_by_town)
# Plot "Distribution of Population for each Town"
#myPalette(low = "white", high = c("green", "red"), mid=NULL, k =50)-Need "GLAD" package
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$total_population_log), max(geo_pop_by_town$total_population_log)))
poppulation_distribution <-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$total_population_log),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
#geom_text(aes(label = town_name, x = longitude, y = latitude),
#data = subset(geo_pop_by_town, total_population_log %in% head(sort(total_population_log, decreasing=TRUE), 3)), check_overlap = TRUE, size=7) +
labs(color='Total Population in Log') +
ggtitle("Distribution of Population for each Town")
poppulation_distribution
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(2)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(8)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
#Plot dependency ratio
sc <- scale_colour_gradientn(colours =palette(rainbow(5)), limits=c(min(geo_pop_by_town$dependency_ratio), max(geo_pop_by_town$dependency_ratio)))
dependency_ratio_plot<-
FraMap +
geom_point(aes(x=geo_pop_by_town$longitude, y=geo_pop_by_town$latitude, colour=geo_pop_by_town$dependency_ratio),
data=geo_pop_by_town, alpha=0.8, size=0.6) +
sc +
labs(color='dependency ratio') +
ggtitle("Dependency ratio of each town")
dependency_ratio_plot
max(geo_pop_by_town$dependency_ratio)
pop_by_department$dep_ratio <-((pop_by_department$child+pop_by_department$elderly)/pop_by_department$workforce)*100
# Group population data by department because of small size of some towns and the given geojson file of department
pop_by_department <- ddply(geo_pop_by_town, .(department), function(geo_pop_by_town) {
data.frame(total_population = sum(geo_pop_by_town$total_population),
male = sum(geo_pop_by_town$male),
female = sum(geo_pop_by_town$female),
child = sum(geo_pop_by_town$child),
elderly = sum(geo_pop_by_town$elderly),
dependent = sum(geo_pop_by_town$dependent),
workforce = sum(geo_pop_by_town$workforce)
)})
summary(pop_by_department)
pop_by_department$dependency_ratio <- pop_by_department$dependent / pop_by_department$workforce
pop_by_department$aged_dependency_ratio <- pop_by_department$elderly / pop_by_department$workforce
pop_by_department$child_dependency_ratio <- pop_by_department$child / pop_by_department$workforce
pop_by_department$dep_ratio <-((pop_by_department$child+pop_by_department$elderly)/pop_by_department$workforce)*100
View(geo_pop_by_town)
# Group population data by department because of small size of some towns and the given geojson file of department
pop_by_department <- ddply(geo_pop_by_town, .(department), function(geo_pop_by_town) {
data.frame(total_population = sum(geo_pop_by_town$total_population),
male = sum(geo_pop_by_town$male),
female = sum(geo_pop_by_town$female),
child = sum(geo_pop_by_town$child),
elderly = sum(geo_pop_by_town$elderly),
dependent = sum(geo_pop_by_town$dependent),
workforce = sum(geo_pop_by_town$workforce)
)})
pop_by_department$dependency_ratio <- pop_by_department$dependent / pop_by_department$workforce
pop_by_department$aged_dependency_ratio <- pop_by_department$elderly / pop_by_department$workforce
pop_by_department$child_dependency_ratio <- pop_by_department$child / pop_by_department$workforce
pop_by_department$dep_ratio <-((pop_by_department$child+pop_by_department$elderly)/pop_by_department$workforce)*100
summary(pop_by_department)
# Group population data by department because of small size of some towns and the given geojson file of department
pop_by_department <- ddply(geo_pop_by_town, .(department), function(geo_pop_by_town) {
data.frame(total_population = sum(geo_pop_by_town$total_population),
male = sum(geo_pop_by_town$male),
female = sum(geo_pop_by_town$female),
child = sum(geo_pop_by_town$child),
elderly = sum(geo_pop_by_town$elderly),
dependent = sum(geo_pop_by_town$dependent),
workforce = sum(geo_pop_by_town$workforce)
)})
pop_by_department$dependency_ratio <- pop_by_department$dependent / pop_by_department$workforce
pop_by_department$aged_dependency_ratio <- pop_by_department$elderly / pop_by_department$workforce
pop_by_department$child_dependency_ratio <- pop_by_department$child / pop_by_department$workforce
summary(pop_by_department)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = Age, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of population") + theme(plot.title = element_text(hjust = 0.5)) + labs(y = "Population") +
coord_flip()
print(pop_pyramid)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of population") + theme(plot.title = element_text(hjust = 0.5)) + labs(y = "Population") + labs(x= "Age")
coord_flip()
print(pop_pyramid)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of Population") + theme(plot.title = element_text(hjust = 0.5)) + labs(x= "Age")+ labs(y = "Population")
coord_flip()
print(pop_pyramid)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of Population") + theme(plot.title = element_text(hjust = 0.5)) + labs(x= "Age")+ labs(y = "Population")
#  coord_flip()
print(pop_pyramid)
population_data2 <- ddply(population, .(sex, ageCateg5), function(population) {
data.frame(total_population = sum(population$peopleCategNum))
})
pop_pyramid <- ggplot(data = population_data2,
mapping = aes(x = ageCateg5, fill = sex,
y = ifelse(test = sex == "Male",
yes = -total_population, no = total_population))) +
geom_bar(stat = "identity") +
scale_y_continuous(labels = abs, limits = max(population_data2$total_population) * c(-1,1)) + ggtitle("Pyramid of Population") + theme(plot.title = element_text(hjust = 0.5)) + labs(x= "Age")+ labs(y = "Population") + coord_flip()
print(pop_pyramid)
print(pop_pyramid)
